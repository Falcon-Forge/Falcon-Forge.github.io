<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Falcon Forge - Free online file converter. Convert images, documents, videos, audio, and archives instantly in your browser. No uploads required, 100% private.">
    <meta name="keywords" content="file converter, image converter, pdf converter, video converter, audio converter, png converter, jpg converter, webp converter, online converter, free converter">
    <meta name="theme-color" content="#0a0a0f">
    <title>Falcon Forge — Universal File Converter</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- JSZip for archive functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- PDF-lib for PDF creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <!-- jsPDF for document to PDF conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- FFmpeg for video/audio conversion -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.min.js"></script>
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --accent-cyan: #00f5d4;
            --accent-magenta: #f72585;
            --accent-yellow: #fee440;
            --text-primary: #ffffff;
            --text-secondary: #8888a0;
            --border-color: #2a2a3a;
            --glow-cyan: 0 0 30px rgba(0, 245, 212, 0.3);
            --glow-magenta: 0 0 30px rgba(247, 37, 133, 0.3);
        }

        /* Light theme */
        [data-theme="light"] {
            --bg-dark: #f5f5f7;
            --bg-card: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #666680;
            --border-color: #d0d0e0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background grid */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 245, 212, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 212, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(247, 37, 133, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(0, 245, 212, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 50px;
            animation: fadeInDown 0.8s ease-out;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            font-family: 'Syne', sans-serif;
            font-size: clamp(2.5rem, 8vw, 4rem);
            font-weight: 800;
            letter-spacing: -2px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            position: relative;
            display: inline-block;
        }

        .logo::after {
            content: '▪';
            position: absolute;
            right: -20px;
            top: 0;
            font-size: 0.5em;
            -webkit-text-fill-color: var(--accent-yellow);
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .tagline {
            font-size: 0.85rem;
            color: var(--text-secondary);
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        /* Main card */
        .converter-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 24px;
            padding: 40px;
            position: relative;
            overflow: hidden;
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .converter-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta), var(--accent-yellow));
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.05);
            box-shadow: var(--glow-cyan);
        }

        .drop-zone-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            position: relative;
        }

        .drop-zone-icon svg {
            width: 100%;
            height: 100%;
            stroke: var(--accent-cyan);
            fill: none;
            stroke-width: 1.5;
        }

        .drop-zone-text {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .drop-zone-hint {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .drop-zone input {
            display: none;
        }

        /* Preview area */
        .preview-area {
            display: none;
            margin-top: 30px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .preview-area.active {
            display: block;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .preview-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 245, 212, 0.1);
            border: 1px solid var(--accent-cyan);
            border-radius: 100px;
            font-size: 0.75rem;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .file-size {
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .remove-btn {
            background: transparent;
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .remove-btn:hover {
            background: var(--accent-magenta);
            color: var(--bg-dark);
        }

        .preview-image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            max-height: 400px;
            overflow: hidden;
            border-radius: 12px;
            background: repeating-conic-gradient(#1a1a2a 0% 25%, #15151f 0% 50%) 50% / 20px 20px;
        }

        .preview-image-container img {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Format selector */
        .format-section {
            margin-top: 30px;
            animation: fadeIn 0.5s ease-out 0.1s both;
        }

        .section-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            display: block;
        }

        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
        }

        .format-option {
            position: relative;
        }

        .format-option input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .format-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .format-option label:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.05);
        }

        .format-option input:checked + label {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.1);
            box-shadow: var(--glow-cyan);
        }

        .format-name {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .format-desc {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Quality slider */
        .quality-section {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            display: none;
        }

        .quality-section.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .quality-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .quality-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-yellow);
        }

        .quality-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
        }

        .quality-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-yellow);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .quality-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .quality-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-yellow);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Convert button */
        .convert-btn {
            width: 100%;
            margin-top: 30px;
            padding: 20px 40px;
            font-family: 'Syne', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--bg-dark);
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .convert-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0, 245, 212, 0.3);
        }

        .convert-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .convert-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .convert-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .convert-btn:hover:not(:disabled)::before {
            left: 100%;
        }

        /* Progress bar */
        .progress-container {
            display: none;
            margin-top: 20px;
        }

        .progress-container.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .progress-bar {
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Footer */
        footer {
            margin-top: auto;
            padding-top: 40px;
            text-align: center;
            animation: fadeIn 0.8s ease-out 0.4s both;
        }

        .supported-formats {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .format-tag {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            letter-spacing: 1px;
        }

        .footer-text {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .footer-text a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        .footer-text a:hover {
            text-decoration: underline;
        }

        /* Theme toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            border-color: var(--accent-cyan);
            box-shadow: var(--glow-cyan);
        }

        .theme-toggle svg {
            width: 24px;
            height: 24px;
            fill: var(--text-primary);
            transition: transform 0.3s ease;
        }

        .theme-toggle:hover svg {
            transform: rotate(30deg);
        }

        .sun-icon, .moon-icon {
            display: none;
        }

        [data-theme="dark"] .moon-icon,
        :root:not([data-theme]) .moon-icon {
            display: block;
        }

        [data-theme="light"] .sun-icon {
            display: block;
        }

        [data-theme="light"] .moon-icon {
            display: none;
        }

        /* Keyboard shortcuts modal */
        .shortcuts-btn {
            position: fixed;
            top: 20px;
            right: 80px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.3s ease;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .shortcuts-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h3 {
            font-family: 'Syne', sans-serif;
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .shortcut-item:last-child {
            border-bottom: none;
        }

        .shortcut-key {
            background: rgba(0, 245, 212, 0.1);
            border: 1px solid var(--accent-cyan);
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--accent-cyan);
        }

        .shortcut-desc {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .modal-close {
            margin-top: 20px;
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        /* Image dimensions display */
        .image-dimensions {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .dimension-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: rgba(247, 37, 133, 0.1);
            border: 1px solid var(--accent-magenta);
            border-radius: 100px;
            font-size: 0.7rem;
            color: var(--accent-magenta);
        }

        /* Image controls (rotate, flip) */
        .image-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.75rem;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .control-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* Resize section */
        .resize-section {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
        }

        /* Compression section */
        .compression-section {
            margin-top: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
        }

        .compression-inputs {
            display: none;
            gap: 15px;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .compression-inputs.active {
            display: flex;
        }

        .compression-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .compression-field label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .compression-field input,
        .compression-field select {
            width: 140px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
        }

        .compression-field input:focus,
        .compression-field select:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .compression-field select option {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .size-estimate {
            margin-top: 15px;
            padding: 12px 16px;
            background: rgba(254, 228, 64, 0.1);
            border: 1px solid var(--accent-yellow);
            border-radius: 8px;
            font-size: 0.8rem;
            color: var(--accent-yellow);
            display: none;
        }

        .size-estimate.active {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .size-estimate svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            flex-shrink: 0;
        }

        .compression-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        .resize-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .resize-toggle input {
            display: none;
        }

        .toggle-switch {
            width: 44px;
            height: 24px;
            background: var(--border-color);
            border-radius: 12px;
            position: relative;
            transition: background 0.3s ease;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: var(--text-primary);
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .resize-toggle input:checked + .toggle-switch {
            background: var(--accent-cyan);
        }

        .resize-toggle input:checked + .toggle-switch::after {
            transform: translateX(20px);
        }

        .resize-inputs {
            display: none;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .resize-inputs.active {
            display: flex;
        }

        .resize-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .resize-field label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .resize-field input {
            width: 100px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
        }

        .resize-field input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .aspect-ratio-lock {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.75rem;
            padding: 10px;
        }

        .aspect-ratio-lock input {
            display: none;
        }

        .lock-icon {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .aspect-ratio-lock:hover {
            color: var(--accent-cyan);
        }

        .aspect-ratio-lock input:checked ~ .lock-icon {
            stroke: var(--accent-cyan);
        }

        /* Filename input */
        .filename-section {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .filename-field {
            flex: 1;
        }

        .filename-field label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .filename-field input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
        }

        .filename-field input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        /* Copy to clipboard button */
        .secondary-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .secondary-btn {
            flex: 1;
            padding: 14px 20px;
            font-family: 'Syne', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-primary);
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .secondary-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .secondary-btn svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* Multiple files support */
        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .file-item-thumb {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            object-fit: cover;
            background: var(--border-color);
        }

        .file-item-info {
            flex: 1;
            min-width: 0;
        }

        .file-item-name {
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-item-size {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .file-item-remove {
            background: transparent;
            border: none;
            color: var(--accent-magenta);
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .file-item-remove:hover {
            background: rgba(247, 37, 133, 0.1);
        }

        .file-item-remove svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .add-more-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .add-more-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .add-more-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .batch-info {
            text-align: center;
            padding: 10px;
            background: rgba(0, 245, 212, 0.05);
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Skip link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--accent-cyan);
            color: var(--bg-dark);
            padding: 8px 16px;
            z-index: 1001;
            text-decoration: none;
            font-weight: 600;
            border-radius: 0 0 8px 0;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Focus styles for accessibility */
        *:focus-visible {
            outline: 2px solid var(--accent-cyan);
            outline-offset: 2px;
        }

        button:focus-visible,
        input:focus-visible,
        label:focus-visible {
            outline: 2px solid var(--accent-cyan);
            outline-offset: 2px;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 16px 30px;
            background: var(--bg-card);
            border: 1px solid var(--accent-cyan);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0;
            transition: all 0.4s ease;
            box-shadow: var(--glow-cyan);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.error {
            border-color: var(--accent-magenta);
            box-shadow: var(--glow-magenta);
        }

        /* Responsive */
        @media (max-width: 600px) {
            .converter-card {
                padding: 25px;
            }

            .drop-zone {
                padding: 40px 20px;
            }

            .preview-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .format-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .category-nav {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 10px;
            }

            .category-btn {
                flex-shrink: 0;
            }
        }

        /* Category Navigation */
        .category-nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .category-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-secondary);
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .category-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        .category-btn.active {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.1);
            color: var(--accent-cyan);
            box-shadow: var(--glow-cyan);
        }

        .category-btn svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .category-icon {
            width: 20px;
            height: 20px;
        }

        /* Converter sections */
        .converter-section {
            display: none;
        }

        .converter-section.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        /* File type tags in drop zone */
        .file-type-tags {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
        }

        .file-type-tag {
            padding: 4px 10px;
            background: rgba(0, 245, 212, 0.1);
            border: 1px solid rgba(0, 245, 212, 0.3);
            border-radius: 20px;
            font-size: 0.65rem;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Preview for different file types */
        .file-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            text-align: center;
        }

        .file-icon {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            stroke: var(--accent-cyan);
            fill: none;
            stroke-width: 1.5;
        }

        .file-name {
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 5px;
            word-break: break-all;
        }

        .file-type {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Video/Audio preview */
        .media-preview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 12px;
        }

        /* Text preview */
        .text-preview {
            max-height: 300px;
            overflow: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: left;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 2000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .loading-progress {
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        /* Feature cards */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .feature-card {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            border-color: var(--accent-cyan);
            transform: translateY(-2px);
        }

        .feature-card svg {
            width: 40px;
            height: 40px;
            stroke: var(--accent-cyan);
            fill: none;
            stroke-width: 1.5;
            margin-bottom: 10px;
        }

        .feature-card h4 {
            font-family: 'Syne', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .feature-card p {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Archive file list */
        .archive-contents {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 15px;
        }

        .archive-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .archive-item:last-child {
            border-bottom: none;
        }

        .archive-item svg {
            width: 16px;
            height: 16px;
            stroke: var(--text-secondary);
            fill: none;
            stroke-width: 2;
            flex-shrink: 0;
        }

        .archive-item-name {
            flex: 1;
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .archive-item-size {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Conversion options grid */
        .conversion-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .conversion-option {
            position: relative;
        }

        .conversion-option input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .conversion-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .conversion-option label:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.05);
        }

        .conversion-option input:checked + label {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.1);
            box-shadow: var(--glow-cyan);
        }

        .conversion-option .format-name {
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .conversion-option .format-desc {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <div class="bg-grid" aria-hidden="true"></div>
    <div class="bg-gradient" aria-hidden="true"></div>

    <!-- Theme toggle button -->
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark/light theme" title="Toggle theme (T)">
        <svg class="sun-icon" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="5"/>
            <line x1="12" y1="1" x2="12" y2="3"/>
            <line x1="12" y1="21" x2="12" y2="23"/>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
            <line x1="1" y1="12" x2="3" y2="12"/>
            <line x1="21" y1="12" x2="23" y2="12"/>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
        </svg>
        <svg class="moon-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
        </svg>
    </button>

    <!-- Keyboard shortcuts button -->
    <button class="shortcuts-btn" id="shortcutsBtn" aria-label="View keyboard shortcuts" title="Keyboard shortcuts (?)">
        <span>?</span>
    </button>

    <!-- Keyboard shortcuts modal -->
    <div class="modal-overlay" id="shortcutsModal" role="dialog" aria-labelledby="shortcutsTitle" aria-modal="true">
        <div class="modal">
            <h3 id="shortcutsTitle">⌨️ Keyboard Shortcuts</h3>
            <div class="shortcut-item">
                <span class="shortcut-desc">Open file dialog</span>
                <span class="shortcut-key">O</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Convert & download</span>
                <span class="shortcut-key">Enter</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Copy to clipboard</span>
                <span class="shortcut-key">C</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Remove image</span>
                <span class="shortcut-key">Delete</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Rotate left</span>
                <span class="shortcut-key">←</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Rotate right</span>
                <span class="shortcut-key">→</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Flip horizontal</span>
                <span class="shortcut-key">H</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Flip vertical</span>
                <span class="shortcut-key">V</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Toggle theme</span>
                <span class="shortcut-key">T</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-desc">Close modal</span>
                <span class="shortcut-key">Esc</span>
            </div>
            <button class="modal-close" id="closeShortcuts">Close</button>
        </div>
    </div>

    <div class="container">
        <header>
            <h1 class="logo">Falcon Forge</h1>
            <p class="tagline">Transform your files instantly</p>
        </header>

        <!-- Category Navigation -->
        <nav class="category-nav" role="tablist" aria-label="Converter categories">
            <button class="category-btn active" data-category="image" role="tab" aria-selected="true" aria-controls="image-converter">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                </svg>
                Images
            </button>
            <button class="category-btn" data-category="document" role="tab" aria-selected="false" aria-controls="document-converter">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="16" y1="13" x2="8" y2="13"/>
                    <line x1="16" y1="17" x2="8" y2="17"/>
                </svg>
                Documents
            </button>
            <button class="category-btn" data-category="video" role="tab" aria-selected="false" aria-controls="video-converter">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <polygon points="23 7 16 12 23 17 23 7"/>
                    <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                </svg>
                Video
            </button>
            <button class="category-btn" data-category="audio" role="tab" aria-selected="false" aria-controls="audio-converter">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                </svg>
                Audio
            </button>
            <button class="category-btn" data-category="archive" role="tab" aria-selected="false" aria-controls="archive-converter">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <line x1="12" y1="11" x2="12" y2="17"/>
                    <line x1="9" y1="14" x2="15" y2="14"/>
                </svg>
                Archives
            </button>
        </nav>

        <main class="converter-card" id="main-content" role="main" aria-label="File converter">
            
            <!-- ============================================== -->
            <!-- IMAGE CONVERTER SECTION -->
            <!-- ============================================== -->
            <div class="converter-section active" id="image-converter" role="tabpanel" aria-labelledby="image-tab">
                <div class="drop-zone" id="dropZone" role="button" tabindex="0" aria-label="Drop zone for image upload. Click or drag and drop images here.">
                    <div class="drop-zone-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="17 8 12 3 7 8"/>
                            <line x1="12" y1="3" x2="12" y2="15"/>
                        </svg>
                    </div>
                    <p class="drop-zone-text">Drop your image(s) here or click to browse</p>
                    <p class="drop-zone-hint">Supports PNG, JPG, WebP, GIF, BMP, TIFF, ICO, SVG, AVIF • Multiple files supported</p>
                    <div class="file-type-tags">
                        <span class="file-type-tag">PNG</span>
                        <span class="file-type-tag">JPG</span>
                        <span class="file-type-tag">WebP</span>
                        <span class="file-type-tag">GIF</span>
                        <span class="file-type-tag">BMP</span>
                        <span class="file-type-tag">AVIF</span>
                        <span class="file-type-tag">SVG</span>
                        <span class="file-type-tag">TIFF</span>
                    </div>
                    <input type="file" id="fileInput" accept="image/*,.svg,.avif" multiple aria-label="File input">
                </div>

            <div class="preview-area" id="previewArea" aria-live="polite">
                <div class="preview-header">
                    <div class="preview-info">
                        <span class="file-badge" id="fileBadge">PNG</span>
                        <span class="file-size" id="fileSize">0 KB</span>
                        <span class="dimension-badge" id="imageDimensions" aria-label="Image dimensions">
                            <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="2" aria-hidden="true">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            </svg>
                            <span id="dimensionText">0 × 0</span>
                        </span>
                    </div>
                    <button class="remove-btn" id="removeBtn" aria-label="Remove selected image">Remove</button>
                </div>
                <div class="preview-image-container">
                    <img id="previewImage" src="" alt="Preview of uploaded image">
                </div>
                
                <!-- Image controls -->
                <div class="image-controls" role="group" aria-label="Image transformation controls">
                    <button class="control-btn" id="rotateLeftBtn" aria-label="Rotate image left 90 degrees" title="Rotate left (←)">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 .57-8.38"/>
                        </svg>
                        Rotate Left
                    </button>
                    <button class="control-btn" id="rotateRightBtn" aria-label="Rotate image right 90 degrees" title="Rotate right (→)">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/>
                        </svg>
                        Rotate Right
                    </button>
                    <button class="control-btn" id="flipHBtn" aria-label="Flip image horizontally" title="Flip horizontal (H)">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/>
                            <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
                            <line x1="12" y1="20" x2="12" y2="4"/>
                        </svg>
                        Flip H
                    </button>
                    <button class="control-btn" id="flipVBtn" aria-label="Flip image vertically" title="Flip vertical (V)">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M3 8V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v3"/>
                            <path d="M3 16v3a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-3"/>
                            <line x1="4" y1="12" x2="20" y2="12"/>
                        </svg>
                        Flip V
                    </button>
                </div>

                <!-- File list for multiple files -->
                <div class="file-list" id="fileList" aria-label="Uploaded files list"></div>
                <button class="add-more-btn" id="addMoreBtn" style="display: none;" aria-label="Add more images">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add more images
                </button>
                <div class="batch-info" id="batchInfo" style="display: none;" aria-live="polite">
                    <span id="batchCount">0</span> images selected • All will be converted with the same settings
                </div>
            </div>

            <div class="format-section" id="formatSection" style="display: none;">
                <label class="section-label" id="formatLabel">Convert to</label>
                <div class="format-grid" role="radiogroup" aria-labelledby="formatLabel">
                    <div class="format-option">
                        <input type="radio" name="format" id="formatPng" value="png" checked>
                        <label for="formatPng">
                            <span class="format-name">PNG</span>
                            <span class="format-desc">Lossless</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatJpg" value="jpeg">
                        <label for="formatJpg">
                            <span class="format-name">JPG</span>
                            <span class="format-desc">Compressed</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatWebp" value="webp">
                        <label for="formatWebp">
                            <span class="format-name">WebP</span>
                            <span class="format-desc">Modern</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatAvif" value="avif">
                        <label for="formatAvif">
                            <span class="format-name">AVIF</span>
                            <span class="format-desc">Next-Gen</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatGif" value="gif">
                        <label for="formatGif">
                            <span class="format-name">GIF</span>
                            <span class="format-desc">256 Colors</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatBmp" value="bmp">
                        <label for="formatBmp">
                            <span class="format-name">BMP</span>
                            <span class="format-desc">Bitmap</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatIco" value="ico">
                        <label for="formatIco">
                            <span class="format-name">ICO</span>
                            <span class="format-desc">Icon</span>
                        </label>
                    </div>
                    <div class="format-option">
                        <input type="radio" name="format" id="formatTiff" value="tiff">
                        <label for="formatTiff">
                            <span class="format-name">TIFF</span>
                            <span class="format-desc">Print</span>
                        </label>
                    </div>
                </div>

                <!-- Resize section -->
                <div class="resize-section">
                    <label class="resize-toggle">
                        <input type="checkbox" id="resizeToggle">
                        <span class="toggle-switch"></span>
                        <span class="section-label" style="margin: 0;">Resize image</span>
                    </label>
                    <div class="resize-inputs" id="resizeInputs">
                        <div class="resize-field">
                            <label for="resizeWidth">Width (px)</label>
                            <input type="number" id="resizeWidth" min="1" max="10000" placeholder="Width" aria-label="Resize width in pixels">
                        </div>
                        <label class="aspect-ratio-lock" title="Lock aspect ratio">
                            <input type="checkbox" id="aspectRatioLock" checked>
                            <svg class="lock-icon" viewBox="0 0 24 24" aria-hidden="true">
                                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                            </svg>
                            <span>Lock ratio</span>
                        </label>
                        <div class="resize-field">
                            <label for="resizeHeight">Height (px)</label>
                            <input type="number" id="resizeHeight" min="1" max="10000" placeholder="Height" aria-label="Resize height in pixels">
                        </div>
                    </div>
                </div>

                <!-- Compression/File size reduction section -->
                <div class="compression-section">
                    <label class="resize-toggle">
                        <input type="checkbox" id="compressionToggle">
                        <span class="toggle-switch"></span>
                        <span class="section-label" style="margin: 0;">Reduce file size</span>
                    </label>
                    <div class="compression-inputs" id="compressionInputs">
                        <div class="compression-field">
                            <label for="targetSize">Target size (KB)</label>
                            <input type="number" id="targetSize" min="10" max="10000" placeholder="e.g. 500" aria-label="Target file size in kilobytes">
                        </div>
                        <div class="compression-field">
                            <label for="maxDimension">Max dimension (px)</label>
                            <input type="number" id="maxDimension" min="100" max="10000" placeholder="e.g. 1920" aria-label="Maximum width or height in pixels">
                        </div>
                    </div>
                    <div class="size-estimate" id="sizeEstimate">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="16" x2="12" y2="12"/>
                            <line x1="12" y1="8" x2="12.01" y2="8"/>
                        </svg>
                        <span id="sizeEstimateText">Estimated output size will be shown here</span>
                    </div>
                    <p class="compression-hint">Note: Compression works best with JPEG and WebP formats. Very low target sizes may reduce image quality.</p>
                </div>

                <div class="quality-section" id="qualitySection">
                    <div class="quality-header">
                        <span class="section-label" style="margin: 0;">Quality</span>
                        <span class="quality-value" id="qualityValue">92%</span>
                    </div>
                    <input type="range" class="quality-slider" id="qualitySlider" min="10" max="100" value="92" aria-label="Image quality percentage">
                </div>

                <!-- Filename customization -->
                <div class="filename-section">
                    <div class="filename-field">
                        <label for="outputFilename">Output filename</label>
                        <input type="text" id="outputFilename" placeholder="Enter filename (without extension)" aria-label="Custom output filename">
                    </div>
                </div>

                <button class="convert-btn" id="convertBtn" disabled aria-label="Convert and download image">
                    Convert & Download
                </button>

                <div class="secondary-actions">
                    <button class="secondary-btn" id="copyBtn" aria-label="Copy converted image to clipboard" title="Copy to clipboard (C)">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                        </svg>
                        Copy to Clipboard
                    </button>
                </div>

                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <p class="progress-text" id="progressText" aria-live="polite">Processing...</p>
                </div>
            </div>
            </div> <!-- End of image-converter section -->

            <!-- ============================================== -->
            <!-- DOCUMENT CONVERTER SECTION -->
            <!-- ============================================== -->
            <div class="converter-section" id="document-converter" role="tabpanel" aria-labelledby="document-tab">
                <div class="drop-zone" id="docDropZone" role="button" tabindex="0" aria-label="Drop zone for document upload. Click or drag and drop documents here.">
                    <div class="drop-zone-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <polyline points="14 2 14 8 20 8"/>
                            <line x1="16" y1="13" x2="8" y2="13"/>
                            <line x1="16" y1="17" x2="8" y2="17"/>
                        </svg>
                    </div>
                    <p class="drop-zone-text">Drop your document here or click to browse</p>
                    <p class="drop-zone-hint">Supports TXT, HTML, Markdown, CSV, JSON • Convert to PDF, TXT, HTML</p>
                    <div class="file-type-tags">
                        <span class="file-type-tag">TXT</span>
                        <span class="file-type-tag">HTML</span>
                        <span class="file-type-tag">MD</span>
                        <span class="file-type-tag">CSV</span>
                        <span class="file-type-tag">JSON</span>
                        <span class="file-type-tag">PDF</span>
                    </div>
                    <input type="file" id="docFileInput" accept=".txt,.html,.htm,.md,.markdown,.csv,.json,.xml" aria-label="Document file input">
                </div>

                <div class="preview-area" id="docPreviewArea" aria-live="polite">
                    <div class="preview-header">
                        <div class="preview-info">
                            <span class="file-badge" id="docFileBadge">TXT</span>
                            <span class="file-size" id="docFileSize">0 KB</span>
                        </div>
                        <button class="remove-btn" id="docRemoveBtn" aria-label="Remove selected document">Remove</button>
                    </div>
                    <div class="text-preview" id="docTextPreview"></div>

                    <div class="format-section" id="docFormatSection" style="display: block; margin-top: 20px;">
                        <label class="section-label">Convert to</label>
                        <div class="conversion-options" role="radiogroup">
                            <div class="conversion-option">
                                <input type="radio" name="docFormat" id="docFormatPdf" value="pdf" checked>
                                <label for="docFormatPdf">
                                    <span class="format-name">PDF</span>
                                    <span class="format-desc">Document</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="docFormat" id="docFormatTxt" value="txt">
                                <label for="docFormatTxt">
                                    <span class="format-name">TXT</span>
                                    <span class="format-desc">Plain Text</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="docFormat" id="docFormatHtml" value="html">
                                <label for="docFormatHtml">
                                    <span class="format-name">HTML</span>
                                    <span class="format-desc">Web Page</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="docFormat" id="docFormatMd" value="md">
                                <label for="docFormatMd">
                                    <span class="format-name">MD</span>
                                    <span class="format-desc">Markdown</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="docFormat" id="docFormatCsv" value="csv">
                                <label for="docFormatCsv">
                                    <span class="format-name">CSV</span>
                                    <span class="format-desc">Spreadsheet</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="docFormat" id="docFormatJson" value="json">
                                <label for="docFormatJson">
                                    <span class="format-name">JSON</span>
                                    <span class="format-desc">Data</span>
                                </label>
                            </div>
                        </div>

                        <div class="filename-section">
                            <div class="filename-field">
                                <label for="docOutputFilename">Output filename</label>
                                <input type="text" id="docOutputFilename" placeholder="Enter filename (without extension)">
                            </div>
                        </div>

                        <button class="convert-btn" id="docConvertBtn" aria-label="Convert and download document">
                            Convert & Download
                        </button>

                        <div class="progress-container" id="docProgressContainer">
                            <div class="progress-bar" role="progressbar">
                                <div class="progress-fill" id="docProgressFill"></div>
                            </div>
                            <p class="progress-text" id="docProgressText">Processing...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ============================================== -->
            <!-- VIDEO CONVERTER SECTION -->
            <!-- ============================================== -->
            <div class="converter-section" id="video-converter" role="tabpanel" aria-labelledby="video-tab">
                <div class="drop-zone" id="videoDropZone" role="button" tabindex="0" aria-label="Drop zone for video upload. Click or drag and drop videos here.">
                    <div class="drop-zone-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24">
                            <polygon points="23 7 16 12 23 17 23 7"/>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                        </svg>
                    </div>
                    <p class="drop-zone-text">Drop your video here or click to browse</p>
                    <p class="drop-zone-hint">Supports MP4, WebM, MOV, AVI • Convert to MP4, WebM, GIF</p>
                    <div class="file-type-tags">
                        <span class="file-type-tag">MP4</span>
                        <span class="file-type-tag">WebM</span>
                        <span class="file-type-tag">MOV</span>
                        <span class="file-type-tag">AVI</span>
                        <span class="file-type-tag">GIF</span>
                    </div>
                    <input type="file" id="videoFileInput" accept="video/*,.mp4,.webm,.mov,.avi,.mkv" aria-label="Video file input">
                </div>

                <div class="preview-area" id="videoPreviewArea" aria-live="polite">
                    <div class="preview-header">
                        <div class="preview-info">
                            <span class="file-badge" id="videoFileBadge">MP4</span>
                            <span class="file-size" id="videoFileSize">0 KB</span>
                            <span class="dimension-badge" id="videoDuration">
                                <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <polyline points="12 6 12 12 16 14"/>
                                </svg>
                                <span id="videoDurationText">0:00</span>
                            </span>
                        </div>
                        <button class="remove-btn" id="videoRemoveBtn" aria-label="Remove selected video">Remove</button>
                    </div>
                    <video id="videoPreview" class="media-preview" controls></video>

                    <div class="format-section" id="videoFormatSection" style="display: block; margin-top: 20px;">
                        <label class="section-label">Convert to</label>
                        <div class="conversion-options" role="radiogroup">
                            <div class="conversion-option">
                                <input type="radio" name="videoFormat" id="videoFormatMp4" value="mp4" checked>
                                <label for="videoFormatMp4">
                                    <span class="format-name">MP4</span>
                                    <span class="format-desc">Universal</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="videoFormat" id="videoFormatWebm" value="webm">
                                <label for="videoFormatWebm">
                                    <span class="format-name">WebM</span>
                                    <span class="format-desc">Web Video</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="videoFormat" id="videoFormatGif" value="gif">
                                <label for="videoFormatGif">
                                    <span class="format-name">GIF</span>
                                    <span class="format-desc">Animated</span>
                                </label>
                            </div>
                        </div>

                        <!-- Video quality settings -->
                        <div class="resize-section" style="margin-top: 20px;">
                            <label class="section-label">Resolution</label>
                            <div class="conversion-options" role="radiogroup" style="margin-top: 10px;">
                                <div class="conversion-option">
                                    <input type="radio" name="videoResolution" id="videoRes1080" value="1080" checked>
                                    <label for="videoRes1080">
                                        <span class="format-name">1080p</span>
                                        <span class="format-desc">Full HD</span>
                                    </label>
                                </div>
                                <div class="conversion-option">
                                    <input type="radio" name="videoResolution" id="videoRes720" value="720">
                                    <label for="videoRes720">
                                        <span class="format-name">720p</span>
                                        <span class="format-desc">HD</span>
                                    </label>
                                </div>
                                <div class="conversion-option">
                                    <input type="radio" name="videoResolution" id="videoRes480" value="480">
                                    <label for="videoRes480">
                                        <span class="format-name">480p</span>
                                        <span class="format-desc">SD</span>
                                    </label>
                                </div>
                                <div class="conversion-option">
                                    <input type="radio" name="videoResolution" id="videoResOriginal" value="original">
                                    <label for="videoResOriginal">
                                        <span class="format-name">Original</span>
                                        <span class="format-desc">Keep Size</span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="filename-section">
                            <div class="filename-field">
                                <label for="videoOutputFilename">Output filename</label>
                                <input type="text" id="videoOutputFilename" placeholder="Enter filename (without extension)">
                            </div>
                        </div>

                        <button class="convert-btn" id="videoConvertBtn" aria-label="Convert and download video">
                            Convert & Download
                        </button>

                        <div class="progress-container" id="videoProgressContainer">
                            <div class="progress-bar" role="progressbar">
                                <div class="progress-fill" id="videoProgressFill"></div>
                            </div>
                            <p class="progress-text" id="videoProgressText">Processing...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ============================================== -->
            <!-- AUDIO CONVERTER SECTION -->
            <!-- ============================================== -->
            <div class="converter-section" id="audio-converter" role="tabpanel" aria-labelledby="audio-tab">
                <div class="drop-zone" id="audioDropZone" role="button" tabindex="0" aria-label="Drop zone for audio upload. Click or drag and drop audio files here.">
                    <div class="drop-zone-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                    </div>
                    <p class="drop-zone-text">Drop your audio file here or click to browse</p>
                    <p class="drop-zone-hint">Supports MP3, WAV, OGG, M4A, FLAC • Convert to MP3, WAV, OGG</p>
                    <div class="file-type-tags">
                        <span class="file-type-tag">MP3</span>
                        <span class="file-type-tag">WAV</span>
                        <span class="file-type-tag">OGG</span>
                        <span class="file-type-tag">M4A</span>
                        <span class="file-type-tag">FLAC</span>
                        <span class="file-type-tag">AAC</span>
                    </div>
                    <input type="file" id="audioFileInput" accept="audio/*,.mp3,.wav,.ogg,.m4a,.flac,.aac" aria-label="Audio file input">
                </div>

                <div class="preview-area" id="audioPreviewArea" aria-live="polite">
                    <div class="preview-header">
                        <div class="preview-info">
                            <span class="file-badge" id="audioFileBadge">MP3</span>
                            <span class="file-size" id="audioFileSize">0 KB</span>
                            <span class="dimension-badge" id="audioDuration">
                                <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <polyline points="12 6 12 12 16 14"/>
                                </svg>
                                <span id="audioDurationText">0:00</span>
                            </span>
                        </div>
                        <button class="remove-btn" id="audioRemoveBtn" aria-label="Remove selected audio">Remove</button>
                    </div>
                    <audio id="audioPreview" class="media-preview" controls style="width: 100%;"></audio>

                    <div class="format-section" id="audioFormatSection" style="display: block; margin-top: 20px;">
                        <label class="section-label">Convert to</label>
                        <div class="conversion-options" role="radiogroup">
                            <div class="conversion-option">
                                <input type="radio" name="audioFormat" id="audioFormatMp3" value="mp3" checked>
                                <label for="audioFormatMp3">
                                    <span class="format-name">MP3</span>
                                    <span class="format-desc">Universal</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="audioFormat" id="audioFormatWav" value="wav">
                                <label for="audioFormatWav">
                                    <span class="format-name">WAV</span>
                                    <span class="format-desc">Lossless</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="audioFormat" id="audioFormatOgg" value="ogg">
                                <label for="audioFormatOgg">
                                    <span class="format-name">OGG</span>
                                    <span class="format-desc">Open Format</span>
                                </label>
                            </div>
                        </div>

                        <!-- Audio quality settings -->
                        <div class="quality-section active" style="margin-top: 20px;">
                            <div class="quality-header">
                                <span class="section-label" style="margin: 0;">Bitrate</span>
                                <span class="quality-value" id="audioBitrateValue">192 kbps</span>
                            </div>
                            <input type="range" class="quality-slider" id="audioBitrateSlider" min="64" max="320" value="192" step="32" aria-label="Audio bitrate">
                        </div>

                        <div class="filename-section">
                            <div class="filename-field">
                                <label for="audioOutputFilename">Output filename</label>
                                <input type="text" id="audioOutputFilename" placeholder="Enter filename (without extension)">
                            </div>
                        </div>

                        <button class="convert-btn" id="audioConvertBtn" aria-label="Convert and download audio">
                            Convert & Download
                        </button>

                        <div class="progress-container" id="audioProgressContainer">
                            <div class="progress-bar" role="progressbar">
                                <div class="progress-fill" id="audioProgressFill"></div>
                            </div>
                            <p class="progress-text" id="audioProgressText">Processing...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ============================================== -->
            <!-- ARCHIVE CONVERTER SECTION -->
            <!-- ============================================== -->
            <div class="converter-section" id="archive-converter" role="tabpanel" aria-labelledby="archive-tab">
                <div class="drop-zone" id="archiveDropZone" role="button" tabindex="0" aria-label="Drop zone for archive upload. Click or drag and drop files here.">
                    <div class="drop-zone-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                            <line x1="12" y1="11" x2="12" y2="17"/>
                            <line x1="9" y1="14" x2="15" y2="14"/>
                        </svg>
                    </div>
                    <p class="drop-zone-text">Drop files here to create an archive or drop a ZIP to extract</p>
                    <p class="drop-zone-hint">Create ZIP from any files • Extract ZIP archives • Multiple files supported</p>
                    <div class="file-type-tags">
                        <span class="file-type-tag">ZIP</span>
                        <span class="file-type-tag">Create</span>
                        <span class="file-type-tag">Extract</span>
                    </div>
                    <input type="file" id="archiveFileInput" multiple aria-label="Archive file input">
                </div>

                <div class="preview-area" id="archivePreviewArea" aria-live="polite">
                    <div class="preview-header">
                        <div class="preview-info">
                            <span class="file-badge" id="archiveFileBadge">ZIP</span>
                            <span class="file-size" id="archiveFileSize">0 KB</span>
                            <span class="dimension-badge" id="archiveFileCount">
                                <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="2">
                                    <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/>
                                    <polyline points="13 2 13 9 20 9"/>
                                </svg>
                                <span id="archiveFileCountText">0 files</span>
                            </span>
                        </div>
                        <button class="remove-btn" id="archiveRemoveBtn" aria-label="Remove selected files">Remove</button>
                    </div>
                    
                    <div class="archive-contents" id="archiveContents"></div>

                    <div class="format-section" id="archiveFormatSection" style="display: block; margin-top: 20px;">
                        <label class="section-label" id="archiveActionLabel">Action</label>
                        <div class="conversion-options" role="radiogroup">
                            <div class="conversion-option">
                                <input type="radio" name="archiveAction" id="archiveActionZip" value="zip" checked>
                                <label for="archiveActionZip">
                                    <span class="format-name">Create ZIP</span>
                                    <span class="format-desc">Compress files</span>
                                </label>
                            </div>
                            <div class="conversion-option">
                                <input type="radio" name="archiveAction" id="archiveActionExtract" value="extract">
                                <label for="archiveActionExtract">
                                    <span class="format-name">Extract</span>
                                    <span class="format-desc">Unzip files</span>
                                </label>
                            </div>
                        </div>

                        <div class="filename-section">
                            <div class="filename-field">
                                <label for="archiveOutputFilename">Output filename</label>
                                <input type="text" id="archiveOutputFilename" placeholder="Enter filename (without extension)" value="archive">
                            </div>
                        </div>

                        <button class="convert-btn" id="archiveConvertBtn" aria-label="Create or extract archive">
                            Create ZIP
                        </button>

                        <div class="progress-container" id="archiveProgressContainer">
                            <div class="progress-bar" role="progressbar">
                                <div class="progress-fill" id="archiveProgressFill"></div>
                            </div>
                            <p class="progress-text" id="archiveProgressText">Processing...</p>
                        </div>
                    </div>
                </div>
            </div>

        </main>

        <footer>
            <div class="supported-formats" aria-label="Supported file formats">
                <span class="format-tag">PNG</span>
                <span class="format-tag">JPG</span>
                <span class="format-tag">WebP</span>
                <span class="format-tag">GIF</span>
                <span class="format-tag">PDF</span>
                <span class="format-tag">MP4</span>
                <span class="format-tag">MP3</span>
                <span class="format-tag">ZIP</span>
            </div>
            <p class="footer-text">All conversions happen locally in your browser. <strong>No uploads.</strong> Your privacy is protected.</p>
        </footer>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <p class="loading-text" id="loadingText">Processing...</p>
        <p class="loading-progress" id="loadingProgress"></p>
    </div>

    <div class="toast" id="toast" role="alert" aria-live="assertive"></div>

    <script>
        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const previewArea = document.getElementById('previewArea');
        const previewImage = document.getElementById('previewImage');
        const fileBadge = document.getElementById('fileBadge');
        const fileSize = document.getElementById('fileSize');
        const removeBtn = document.getElementById('removeBtn');
        const formatSection = document.getElementById('formatSection');
        const qualitySection = document.getElementById('qualitySection');
        const qualitySlider = document.getElementById('qualitySlider');
        const qualityValue = document.getElementById('qualityValue');
        const convertBtn = document.getElementById('convertBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const toast = document.getElementById('toast');
        const themeToggle = document.getElementById('themeToggle');
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const closeShortcuts = document.getElementById('closeShortcuts');
        const dimensionText = document.getElementById('dimensionText');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const flipHBtn = document.getElementById('flipHBtn');
        const flipVBtn = document.getElementById('flipVBtn');
        const resizeToggle = document.getElementById('resizeToggle');
        const resizeInputs = document.getElementById('resizeInputs');
        const resizeWidth = document.getElementById('resizeWidth');
        const resizeHeight = document.getElementById('resizeHeight');
        const aspectRatioLock = document.getElementById('aspectRatioLock');
        const outputFilename = document.getElementById('outputFilename');
        const copyBtn = document.getElementById('copyBtn');
        const fileList = document.getElementById('fileList');
        const addMoreBtn = document.getElementById('addMoreBtn');
        const batchInfo = document.getElementById('batchInfo');
        const batchCount = document.getElementById('batchCount');
        const compressionToggle = document.getElementById('compressionToggle');
        const compressionInputs = document.getElementById('compressionInputs');
        const targetSize = document.getElementById('targetSize');
        const maxDimension = document.getElementById('maxDimension');
        const sizeEstimate = document.getElementById('sizeEstimate');
        const sizeEstimateText = document.getElementById('sizeEstimateText');

        let currentFile = null;
        let currentFiles = [];
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 1;
        let rotation = 0;
        let flipH = false;
        let flipV = false;
        let originalFileSize = 0;

        // Initialize theme from localStorage or system preference
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                document.documentElement.setAttribute('data-theme', 'light');
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        }
        initTheme();

        // Theme toggle handler
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });

        // Shortcuts modal handlers
        shortcutsBtn.addEventListener('click', () => {
            shortcutsModal.classList.add('active');
            shortcutsModal.querySelector('.modal-close').focus();
        });

        closeShortcuts.addEventListener('click', () => {
            shortcutsModal.classList.remove('active');
        });

        shortcutsModal.addEventListener('click', (e) => {
            if (e.target === shortcutsModal) {
                shortcutsModal.classList.remove('active');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' && e.target.type !== 'checkbox' && e.target.type !== 'radio') {
                if (e.key === 'Escape') {
                    e.target.blur();
                }
                return;
            }

            // Escape to close modal
            if (e.key === 'Escape') {
                shortcutsModal.classList.remove('active');
                return;
            }

            // ? for shortcuts modal (works on most keyboard layouts)
            if (e.key === '?') {
                e.preventDefault();
                shortcutsModal.classList.add('active');
                return;
            }

            // O for open file
            if (e.key === 'o' || e.key === 'O') {
                e.preventDefault();
                fileInput.click();
                return;
            }

            // T for theme toggle
            if (e.key === 't' || e.key === 'T') {
                e.preventDefault();
                themeToggle.click();
                return;
            }

            // Only if we have an image loaded
            if (currentFile) {
                // Enter for convert
                if (e.key === 'Enter' && !convertBtn.disabled) {
                    e.preventDefault();
                    convertBtn.click();
                    return;
                }

                // C for copy to clipboard (single key, not Ctrl/Cmd+C which is for native copy)
                if ((e.key === 'c' || e.key === 'C') && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    copyBtn.click();
                    return;
                }

                // Delete/Backspace to remove
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    removeBtn.click();
                    return;
                }

                // Arrow keys for rotation
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    rotateLeftBtn.click();
                    return;
                }
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    rotateRightBtn.click();
                    return;
                }

                // H for flip horizontal
                if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    flipHBtn.click();
                    return;
                }

                // V for flip vertical
                if (e.key === 'v' || e.key === 'V') {
                    e.preventDefault();
                    flipVBtn.click();
                    return;
                }
            }
        });

        // Format change handler
        document.querySelectorAll('input[name="format"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const format = e.target.value;
                if (format === 'jpeg' || format === 'webp' || format === 'avif') {
                    qualitySection.classList.add('active');
                } else {
                    qualitySection.classList.remove('active');
                }
            });
        });

        // Quality slider handler
        qualitySlider.addEventListener('input', (e) => {
            qualityValue.textContent = e.target.value + '%';
        });

        // Resize toggle handler
        resizeToggle.addEventListener('change', () => {
            if (resizeToggle.checked) {
                resizeInputs.classList.add('active');
                if (originalWidth && originalHeight) {
                    resizeWidth.value = originalWidth;
                    resizeHeight.value = originalHeight;
                }
            } else {
                resizeInputs.classList.remove('active');
            }
        });

        // Resize input handlers with aspect ratio lock
        resizeWidth.addEventListener('input', () => {
            if (aspectRatioLock.checked && resizeWidth.value && aspectRatio) {
                resizeHeight.value = Math.round(resizeWidth.value / aspectRatio);
            }
        });

        resizeHeight.addEventListener('input', () => {
            if (aspectRatioLock.checked && resizeHeight.value && aspectRatio) {
                resizeWidth.value = Math.round(resizeHeight.value * aspectRatio);
            }
        });

        // Compression toggle handler
        compressionToggle.addEventListener('change', () => {
            if (compressionToggle.checked) {
                compressionInputs.classList.add('active');
                updateSizeEstimate();
            } else {
                compressionInputs.classList.remove('active');
                sizeEstimate.classList.remove('active');
            }
        });

        // Compression input handlers
        targetSize.addEventListener('input', updateSizeEstimate);
        maxDimension.addEventListener('input', updateSizeEstimate);

        // Update size estimate
        function updateSizeEstimate() {
            if (!compressionToggle.checked || !currentFile) {
                sizeEstimate.classList.remove('active');
                return;
            }
            
            const target = parseInt(targetSize.value) || 0;
            const maxDim = parseInt(maxDimension.value) || 0;
            
            if (target > 0 || maxDim > 0) {
                sizeEstimate.classList.add('active');
                let estimateMessage = '';
                
                if (target > 0) {
                    const currentSizeKB = Math.round(originalFileSize / 1024);
                    if (currentSizeKB > target) {
                        estimateMessage = `Will compress from ~${currentSizeKB}KB to target ~${target}KB`;
                    } else {
                        estimateMessage = `Current size (~${currentSizeKB}KB) is already below target`;
                    }
                }
                
                if (maxDim > 0) {
                    const maxOriginal = Math.max(originalWidth, originalHeight);
                    if (maxOriginal > maxDim) {
                        estimateMessage += estimateMessage ? '. ' : '';
                        estimateMessage += `Will scale down from ${maxOriginal}px to ${maxDim}px max`;
                    }
                }
                
                sizeEstimateText.textContent = estimateMessage || 'Enter target size or max dimension';
            } else {
                sizeEstimate.classList.remove('active');
            }
        }

        // Drop zone handlers
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                fileInput.click();
            }
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleFiles(files);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
            }
        });

        // Add more button handler
        addMoreBtn.addEventListener('click', () => {
            fileInput.click();
        });

        // Remove button handler
        removeBtn.addEventListener('click', () => {
            currentFile = null;
            currentFiles = [];
            fileInput.value = '';
            previewArea.classList.remove('active');
            formatSection.style.display = 'none';
            convertBtn.disabled = true;
            dropZone.style.display = 'block';
            fileList.innerHTML = '';
            addMoreBtn.style.display = 'none';
            batchInfo.style.display = 'none';
            resetTransformations();
        });

        // Reset image transformations
        function resetTransformations() {
            rotation = 0;
            flipH = false;
            flipV = false;
            updateImageTransform();
        }

        // Image transformation handlers
        rotateLeftBtn.addEventListener('click', () => {
            rotation = (rotation - 90) % 360;
            updateImageTransform();
        });

        rotateRightBtn.addEventListener('click', () => {
            rotation = (rotation + 90) % 360;
            updateImageTransform();
        });

        flipHBtn.addEventListener('click', () => {
            flipH = !flipH;
            updateImageTransform();
        });

        flipVBtn.addEventListener('click', () => {
            flipV = !flipV;
            updateImageTransform();
        });

        function updateImageTransform() {
            const transforms = [];
            if (rotation !== 0) transforms.push(`rotate(${rotation}deg)`);
            if (flipH) transforms.push('scaleX(-1)');
            if (flipV) transforms.push('scaleY(-1)');
            previewImage.style.transform = transforms.join(' ');
        }

        // Supported image extensions for validation
        const SUPPORTED_IMAGE_EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'ico', 'svg'];

        // Validate file is an image by MIME type and extension
        function isValidImageFile(file) {
            // Check MIME type
            if (!file.type.startsWith('image/')) {
                return false;
            }
            // Also validate extension as additional check
            const extension = file.name.split('.').pop().toLowerCase();
            return SUPPORTED_IMAGE_EXTENSIONS.includes(extension);
        }

        // Handle multiple files
        function handleFiles(files) {
            const validFiles = files.filter(file => isValidImageFile(file));
            
            if (validFiles.length === 0) {
                showToast('Please select valid image files', true);
                return;
            }

            // Add to current files if we already have some
            if (currentFiles.length > 0) {
                currentFiles = [...currentFiles, ...validFiles];
            } else {
                currentFiles = validFiles;
            }

            // Set the first file as current for preview
            currentFile = currentFiles[0];
            
            // Handle single file vs multiple files display
            if (currentFiles.length === 1) {
                handleSingleFile(currentFile);
            } else {
                handleMultipleFiles(currentFiles);
            }
        }

        // Handle single file
        function handleSingleFile(file) {
            const reader = new FileReader();

            reader.onload = (e) => {
                previewImage.src = e.target.result;
                
                // Get image dimensions
                const img = new Image();
                img.onload = () => {
                    originalWidth = img.naturalWidth;
                    originalHeight = img.naturalHeight;
                    aspectRatio = originalWidth / originalHeight;
                    dimensionText.textContent = `${originalWidth} × ${originalHeight}`;
                    
                    // Update resize inputs if active
                    if (resizeToggle.checked) {
                        resizeWidth.value = originalWidth;
                        resizeHeight.value = originalHeight;
                    }
                };
                img.src = e.target.result;
                
                // Update file info
                const ext = file.name.split('.').pop().toUpperCase();
                fileBadge.textContent = ext;
                fileSize.textContent = formatFileSize(file.size);
                originalFileSize = file.size;

                // Set default output filename
                outputFilename.value = file.name.replace(/\.[^/.]+$/, '');

                // Show preview and format options
                dropZone.style.display = 'none';
                previewArea.classList.add('active');
                formatSection.style.display = 'block';
                convertBtn.disabled = false;
                fileList.innerHTML = '';
                addMoreBtn.style.display = 'block';
                batchInfo.style.display = 'none';
                resetTransformations();
                
                // Update size estimate if compression is enabled
                updateSizeEstimate();
            };

            reader.onerror = () => {
                showToast('Error reading file', true);
            };

            reader.readAsDataURL(file);
        }

        // Handle multiple files
        function handleMultipleFiles(files) {
            // Build file list first
            fileList.innerHTML = '';
            batchCount.textContent = files.length;
            batchInfo.style.display = 'block';
            addMoreBtn.style.display = 'block';
            
            // Setup preview for the first file
            setupPreviewForFile(files[0], true);
            
            // Build thumbnail list for all files
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <img src="${e.target.result}" alt="${file.name}" class="file-item-thumb">
                        <div class="file-item-info">
                            <div class="file-item-name">${file.name}</div>
                            <div class="file-item-size">${formatFileSize(file.size)}</div>
                        </div>
                        <button class="file-item-remove" data-index="${index}" aria-label="Remove ${file.name}">
                            <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                        </button>
                    `;
                    fileList.appendChild(item);

                    // Add click handler to preview this file
                    item.querySelector('.file-item-thumb').addEventListener('click', () => {
                        setupPreviewForFile(file, false, e.target.result);
                    });

                    // Add remove handler
                    item.querySelector('.file-item-remove').addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const idx = parseInt(ev.currentTarget.dataset.index);
                        currentFiles.splice(idx, 1);
                        
                        if (currentFiles.length === 0) {
                            removeBtn.click();
                        } else if (currentFiles.length === 1) {
                            handleSingleFile(currentFiles[0]);
                        } else {
                            handleMultipleFiles(currentFiles);
                        }
                    });
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Shared function to setup preview for a file
        function setupPreviewForFile(file, showUI, cachedDataUrl) {
            currentFile = file;
            
            const loadPreview = (dataUrl) => {
                previewImage.src = dataUrl;
                
                const img = new Image();
                img.onload = () => {
                    originalWidth = img.naturalWidth;
                    originalHeight = img.naturalHeight;
                    aspectRatio = originalWidth / originalHeight;
                    dimensionText.textContent = `${originalWidth} × ${originalHeight}`;
                    
                    if (resizeToggle.checked) {
                        resizeWidth.value = originalWidth;
                        resizeHeight.value = originalHeight;
                    }
                };
                img.src = dataUrl;
                
                const ext = file.name.split('.').pop().toUpperCase();
                fileBadge.textContent = ext;
                fileSize.textContent = formatFileSize(file.size);
                originalFileSize = file.size;
                outputFilename.value = file.name.replace(/\.[^/.]+$/, '');
                
                if (showUI) {
                    dropZone.style.display = 'none';
                    previewArea.classList.add('active');
                    formatSection.style.display = 'block';
                    convertBtn.disabled = false;
                }
                
                resetTransformations();
                updateSizeEstimate();
            };
            
            if (cachedDataUrl) {
                loadPreview(cachedDataUrl);
            } else {
                const reader = new FileReader();
                reader.onload = (e) => loadPreview(e.target.result);
                reader.readAsDataURL(file);
            }
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Apply transformations to canvas
        function applyTransformations(ctx, img, width, height) {
            ctx.save();
            ctx.translate(width / 2, height / 2);
            
            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            
            let scaleX = 1;
            let scaleY = 1;
            if (flipH) scaleX = -1;
            if (flipV) scaleY = -1;
            ctx.scale(scaleX, scaleY);
            
            // Adjust dimensions for 90/270 degree rotations
            const isRotated90 = Math.abs(rotation) === 90 || Math.abs(rotation) === 270;
            const drawWidth = isRotated90 ? height : width;
            const drawHeight = isRotated90 ? width : height;
            
            ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            ctx.restore();
        }

        // Process single image
        async function processImage(file, format, quality) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const img = new Image();
                    img.crossOrigin = 'Anonymous';
                    
                    img.onload = async () => {
                        let targetWidth = img.naturalWidth;
                        let targetHeight = img.naturalHeight;

                        // Apply resize if enabled
                        if (resizeToggle.checked && resizeWidth.value && resizeHeight.value) {
                            targetWidth = parseInt(resizeWidth.value);
                            targetHeight = parseInt(resizeHeight.value);
                        }

                        // Apply max dimension constraint from compression settings
                        if (compressionToggle.checked && maxDimension.value) {
                            const maxDim = parseInt(maxDimension.value);
                            const currentMax = Math.max(targetWidth, targetHeight);
                            if (currentMax > maxDim) {
                                const scale = maxDim / currentMax;
                                targetWidth = Math.round(targetWidth * scale);
                                targetHeight = Math.round(targetHeight * scale);
                            }
                        }

                        // Swap dimensions for 90/270 degree rotations
                        const isRotated90 = Math.abs(rotation) === 90 || Math.abs(rotation) === 270;
                        const canvasWidth = isRotated90 ? targetHeight : targetWidth;
                        const canvasHeight = isRotated90 ? targetWidth : targetHeight;

                        const canvas = document.createElement('canvas');
                        
                        // Special handling for ICO (32x32)
                        if (format === 'ico') {
                            canvas.width = 32;
                            canvas.height = 32;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, 32, 32);
                        } else {
                            canvas.width = canvasWidth;
                            canvas.height = canvasHeight;
                            const ctx = canvas.getContext('2d');
                            
                            // Apply transformations
                            if (rotation !== 0 || flipH || flipV) {
                                applyTransformations(ctx, img, canvasWidth, canvasHeight);
                            } else {
                                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                            }
                        }

                        // Determine MIME type
                        let mimeType = `image/${format}`;
                        if (format === 'ico') mimeType = 'image/png';
                        if (format === 'avif') mimeType = 'image/avif';
                        if (format === 'tiff') mimeType = 'image/png'; // Fallback, as tiff isn't supported by canvas

                        // Check if format is supported by canvas
                        const supportsFormat = (fmt) => {
                            const testCanvas = document.createElement('canvas');
                            testCanvas.width = 1;
                            testCanvas.height = 1;
                            const dataUrl = testCanvas.toDataURL(`image/${fmt}`);
                            return dataUrl.startsWith(`data:image/${fmt}`);
                        };

                        // Apply compression to reach target size if enabled
                        const compressibleFormats = ['jpeg', 'webp', 'avif'];
                        if (compressionToggle.checked && targetSize.value && compressibleFormats.includes(format)) {
                            const targetBytes = parseInt(targetSize.value) * 1024;
                            const blob = await compressToTargetSize(canvas, mimeType, quality, targetBytes);
                            resolve(blob);
                        } else {
                            // For formats with quality support
                            const qualityFormats = ['jpeg', 'webp', 'avif'];
                            const useQuality = qualityFormats.includes(format);
                            
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    // Fallback to PNG if format not supported
                                    canvas.toBlob((pngBlob) => {
                                        resolve(pngBlob);
                                    }, 'image/png');
                                }
                            }, mimeType, useQuality ? quality : undefined);
                        }
                    };

                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Compression constants
        const COMPRESSION_MAX_ITERATIONS = 10;
        const COMPRESSION_QUALITY_THRESHOLD = 0.01;
        const COMPRESSION_TARGET_TOLERANCE = 0.8;

        // Compress image to target file size using binary search
        async function compressToTargetSize(canvas, mimeType, initialQuality, targetBytes) {
            return new Promise((resolve) => {
                let minQuality = 0.1;
                let maxQuality = initialQuality;
                let bestBlob = null;
                let iterations = 0;

                function tryQuality(quality) {
                    canvas.toBlob((blob) => {
                        iterations++;
                        
                        // Update best blob if this one is better (under target but larger than previous best under target)
                        const isBlobUnderTarget = blob.size <= targetBytes;
                        const bestBlobSize = bestBlob && bestBlob.size <= targetBytes ? bestBlob.size : 0;
                        if (!bestBlob || (isBlobUnderTarget && blob.size > bestBlobSize)) {
                            bestBlob = blob;
                        }
                        
                        // If we're close enough or max iterations reached, use best result
                        const isCloseEnough = isBlobUnderTarget && blob.size >= targetBytes * COMPRESSION_TARGET_TOLERANCE;
                        if (iterations >= COMPRESSION_MAX_ITERATIONS || isCloseEnough) {
                            resolve(bestBlob || blob);
                            return;
                        }

                        // Binary search for optimal quality
                        if (blob.size > targetBytes) {
                            maxQuality = quality;
                        } else {
                            minQuality = quality;
                        }

                        const nextQuality = (minQuality + maxQuality) / 2;
                        
                        // If quality range is too small, stop
                        if (maxQuality - minQuality < COMPRESSION_QUALITY_THRESHOLD) {
                            resolve(bestBlob || blob);
                            return;
                        }
                        
                        tryQuality(nextQuality);
                    }, mimeType, quality);
                }

                tryQuality(maxQuality);
            });
        }

        // Convert button handler
        convertBtn.addEventListener('click', async () => {
            if (currentFiles.length === 0) return;

            const selectedFormat = document.querySelector('input[name="format"]:checked').value;
            const quality = qualitySlider.value / 100;

            // Show progress
            convertBtn.disabled = true;
            progressContainer.classList.add('active');
            progressFill.style.width = '0%';

            try {
                if (currentFiles.length === 1) {
                    // Single file conversion
                    await animateProgress(30, 'Processing image...');
                    
                    const blob = await processImage(currentFile, selectedFormat, quality);
                    
                    await animateProgress(70, 'Encoding...');

                    // Download
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const filename = outputFilename.value || currentFile.name.replace(/\.[^/.]+$/, '');
                    const extension = selectedFormat === 'jpeg' ? 'jpg' : selectedFormat;
                    a.href = url;
                    a.download = `${filename}.${extension}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    await animateProgress(100, 'Complete!');
                    showToast('Image converted successfully!');
                } else {
                    // Batch conversion - download as zip or individual files
                    const total = currentFiles.length;
                    
                    for (let i = 0; i < currentFiles.length; i++) {
                        const file = currentFiles[i];
                        const progress = Math.round((i / total) * 80) + 10;
                        await animateProgress(progress, `Converting ${i + 1} of ${total}...`);
                        
                        const blob = await processImage(file, selectedFormat, quality);
                        
                        // Download each file
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        const filename = file.name.replace(/\.[^/.]+$/, '');
                        const extension = selectedFormat === 'jpeg' ? 'jpg' : selectedFormat;
                        a.href = url;
                        a.download = `${filename}.${extension}`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        // Delay between downloads to prevent browser blocking
                        const BATCH_DOWNLOAD_DELAY_MS = 200;
                        await new Promise(r => setTimeout(r, BATCH_DOWNLOAD_DELAY_MS));
                    }

                    await animateProgress(100, 'All images converted!');
                    showToast(`${total} images converted successfully!`);
                }

                setTimeout(() => {
                    progressContainer.classList.remove('active');
                    convertBtn.disabled = false;
                }, 500);

            } catch (error) {
                console.error('Conversion error:', error);
                progressContainer.classList.remove('active');
                convertBtn.disabled = false;
                showToast('Error converting image', true);
            }
        });

        // Copy to clipboard handler
        copyBtn.addEventListener('click', async () => {
            if (!currentFile) return;

            try {
                const selectedFormat = document.querySelector('input[name="format"]:checked').value;
                const quality = qualitySlider.value / 100;
                
                // Only PNG is widely supported for clipboard
                const format = 'png';
                const blob = await processImage(currentFile, format, quality);

                await navigator.clipboard.write([
                    new ClipboardItem({
                        'image/png': blob
                    })
                ]);

                showToast('Image copied to clipboard!');
            } catch (error) {
                console.error('Copy error:', error);
                // Fallback message
                if (error.name === 'NotAllowedError') {
                    showToast('Clipboard access denied. Please allow clipboard permissions.', true);
                } else {
                    showToast('Unable to copy to clipboard. Try downloading instead.', true);
                }
            }
        });

        // Animate progress
        function animateProgress(target, text) {
            return new Promise((resolve) => {
                progressText.textContent = text;
                progressFill.style.width = target + '%';
                document.querySelector('.progress-bar').setAttribute('aria-valuenow', target);
                setTimeout(resolve, 300);
            });
        }

        // Toast notification
        function showToast(message, isError = false) {
            toast.textContent = message;
            toast.classList.toggle('error', isError);
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Prevent default drag behavior on window
        window.addEventListener('dragover', (e) => e.preventDefault());
        window.addEventListener('drop', (e) => e.preventDefault());

        // ================================================
        // CATEGORY NAVIGATION
        // ================================================
        const categoryBtns = document.querySelectorAll('.category-btn');
        const converterSections = document.querySelectorAll('.converter-section');

        categoryBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const category = btn.dataset.category;
                
                // Update active button
                categoryBtns.forEach(b => {
                    b.classList.remove('active');
                    b.setAttribute('aria-selected', 'false');
                });
                btn.classList.add('active');
                btn.setAttribute('aria-selected', 'true');
                
                // Show corresponding section
                converterSections.forEach(section => {
                    section.classList.remove('active');
                });
                document.getElementById(`${category}-converter`).classList.add('active');
            });
        });

        // ================================================
        // DOCUMENT CONVERTER
        // ================================================
        const docDropZone = document.getElementById('docDropZone');
        const docFileInput = document.getElementById('docFileInput');
        const docPreviewArea = document.getElementById('docPreviewArea');
        const docTextPreview = document.getElementById('docTextPreview');
        const docFileBadge = document.getElementById('docFileBadge');
        const docFileSize = document.getElementById('docFileSize');
        const docRemoveBtn = document.getElementById('docRemoveBtn');
        const docConvertBtn = document.getElementById('docConvertBtn');
        const docOutputFilename = document.getElementById('docOutputFilename');
        const docProgressContainer = document.getElementById('docProgressContainer');
        const docProgressFill = document.getElementById('docProgressFill');
        const docProgressText = document.getElementById('docProgressText');

        let currentDocFile = null;
        let currentDocContent = '';

        // Document drop zone handlers
        docDropZone.addEventListener('click', () => docFileInput.click());
        docDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            docDropZone.classList.add('dragover');
        });
        docDropZone.addEventListener('dragleave', () => docDropZone.classList.remove('dragover'));
        docDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            docDropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleDocFile(e.dataTransfer.files[0]);
            }
        });
        docFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleDocFile(e.target.files[0]);
            }
        });

        function handleDocFile(file) {
            const validExtensions = ['txt', 'html', 'htm', 'md', 'markdown', 'csv', 'json', 'xml'];
            const ext = file.name.split('.').pop().toLowerCase();
            
            if (!validExtensions.includes(ext)) {
                showToast('Please select a valid document file', true);
                return;
            }

            currentDocFile = file;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                currentDocContent = e.target.result;
                
                // Update UI
                docFileBadge.textContent = ext.toUpperCase();
                docFileSize.textContent = formatFileSize(file.size);
                docOutputFilename.value = file.name.replace(/\.[^/.]+$/, '');
                
                // Show preview (first 2000 chars)
                docTextPreview.textContent = currentDocContent.substring(0, 2000) + 
                    (currentDocContent.length > 2000 ? '\n\n... (truncated)' : '');
                
                docDropZone.style.display = 'none';
                docPreviewArea.classList.add('active');
            };
            reader.readAsText(file);
        }

        docRemoveBtn.addEventListener('click', () => {
            currentDocFile = null;
            currentDocContent = '';
            docFileInput.value = '';
            docPreviewArea.classList.remove('active');
            docDropZone.style.display = 'block';
        });

        docConvertBtn.addEventListener('click', async () => {
            if (!currentDocFile) return;

            const targetFormat = document.querySelector('input[name="docFormat"]:checked').value;
            const filename = docOutputFilename.value || 'document';

            docProgressContainer.classList.add('active');
            docProgressFill.style.width = '50%';
            docProgressText.textContent = 'Converting...';

            try {
                let blob;
                let outputFilename;

                switch (targetFormat) {
                    case 'pdf':
                        blob = await convertDocToPdf(currentDocContent, filename);
                        outputFilename = `${filename}.pdf`;
                        break;
                    case 'txt':
                        blob = new Blob([stripHtml(currentDocContent)], { type: 'text/plain' });
                        outputFilename = `${filename}.txt`;
                        break;
                    case 'html':
                        blob = new Blob([convertToHtml(currentDocContent)], { type: 'text/html' });
                        outputFilename = `${filename}.html`;
                        break;
                    case 'md':
                        blob = new Blob([convertToMarkdown(currentDocContent)], { type: 'text/markdown' });
                        outputFilename = `${filename}.md`;
                        break;
                    case 'csv':
                        blob = new Blob([convertToCsv(currentDocContent)], { type: 'text/csv' });
                        outputFilename = `${filename}.csv`;
                        break;
                    case 'json':
                        blob = new Blob([convertToJson(currentDocContent)], { type: 'application/json' });
                        outputFilename = `${filename}.json`;
                        break;
                }

                docProgressFill.style.width = '100%';
                docProgressText.textContent = 'Complete!';

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = outputFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Document converted successfully!');
            } catch (error) {
                console.error('Document conversion error:', error);
                showToast('Error converting document', true);
            }

            setTimeout(() => {
                docProgressContainer.classList.remove('active');
            }, 500);
        });

        // Document conversion helpers
        async function convertDocToPdf(content, title) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Add title
            doc.setFontSize(16);
            doc.text(title, 20, 20);
            
            // Add content
            doc.setFontSize(11);
            const lines = doc.splitTextToSize(stripHtml(content), 170);
            let y = 35;
            
            for (let i = 0; i < lines.length; i++) {
                if (y > 280) {
                    doc.addPage();
                    y = 20;
                }
                doc.text(lines[i], 20, y);
                y += 6;
            }
            
            return doc.output('blob');
        }

        function stripHtml(html) {
            const tmp = document.createElement('div');
            tmp.innerHTML = html;
            return tmp.textContent || tmp.innerText || '';
        }

        function convertToHtml(content) {
            // If already HTML-like, wrap it properly
            if (content.includes('<html') || content.includes('<body')) {
                return content;
            }
            // Convert plain text to HTML
            const escaped = content
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>\n');
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Converted Document</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; line-height: 1.6; }
    </style>
</head>
<body>
${escaped}
</body>
</html>`;
        }

        function convertToMarkdown(content) {
            // Basic HTML to Markdown conversion
            let md = content;
            md = md.replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n');
            md = md.replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\n\n');
            md = md.replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\n\n');
            md = md.replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n');
            md = md.replace(/<br\s*\/?>/gi, '\n');
            md = md.replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**');
            md = md.replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**');
            md = md.replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*');
            md = md.replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*');
            md = md.replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)');
            md = md.replace(/<[^>]+>/g, ''); // Remove remaining HTML tags
            return md.trim();
        }

        function convertToCsv(content) {
            // Try to detect structure and convert
            const lines = stripHtml(content).split('\n').filter(l => l.trim());
            return lines.map(line => {
                // Escape quotes and wrap in quotes if contains comma
                const escaped = line.replace(/"/g, '""');
                return escaped.includes(',') ? `"${escaped}"` : escaped;
            }).join('\n');
        }

        function convertToJson(content) {
            // Try to parse if already JSON, otherwise create a document object
            try {
                JSON.parse(content);
                return content; // Already valid JSON
            } catch {
                // Create a JSON structure
                const lines = stripHtml(content).split('\n').filter(l => l.trim());
                return JSON.stringify({
                    content: lines,
                    lineCount: lines.length,
                    characterCount: content.length,
                    convertedAt: new Date().toISOString()
                }, null, 2);
            }
        }

        // ================================================
        // VIDEO CONVERTER
        // ================================================
        const videoDropZone = document.getElementById('videoDropZone');
        const videoFileInput = document.getElementById('videoFileInput');
        const videoPreviewArea = document.getElementById('videoPreviewArea');
        const videoPreview = document.getElementById('videoPreview');
        const videoFileBadge = document.getElementById('videoFileBadge');
        const videoFileSize = document.getElementById('videoFileSize');
        const videoDurationText = document.getElementById('videoDurationText');
        const videoRemoveBtn = document.getElementById('videoRemoveBtn');
        const videoConvertBtn = document.getElementById('videoConvertBtn');
        const videoOutputFilename = document.getElementById('videoOutputFilename');
        const videoProgressContainer = document.getElementById('videoProgressContainer');
        const videoProgressFill = document.getElementById('videoProgressFill');
        const videoProgressText = document.getElementById('videoProgressText');

        let currentVideoFile = null;

        // Video drop zone handlers
        videoDropZone.addEventListener('click', () => videoFileInput.click());
        videoDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            videoDropZone.classList.add('dragover');
        });
        videoDropZone.addEventListener('dragleave', () => videoDropZone.classList.remove('dragover'));
        videoDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            videoDropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleVideoFile(e.dataTransfer.files[0]);
            }
        });
        videoFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleVideoFile(e.target.files[0]);
            }
        });

        function handleVideoFile(file) {
            if (!file.type.startsWith('video/')) {
                showToast('Please select a valid video file', true);
                return;
            }

            currentVideoFile = file;
            const url = URL.createObjectURL(file);
            videoPreview.src = url;
            
            videoPreview.onloadedmetadata = () => {
                const duration = videoPreview.duration;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                videoDurationText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            };
            
            const ext = file.name.split('.').pop().toUpperCase();
            videoFileBadge.textContent = ext;
            videoFileSize.textContent = formatFileSize(file.size);
            videoOutputFilename.value = file.name.replace(/\.[^/.]+$/, '');
            
            videoDropZone.style.display = 'none';
            videoPreviewArea.classList.add('active');
        }

        videoRemoveBtn.addEventListener('click', () => {
            currentVideoFile = null;
            videoPreview.src = '';
            videoFileInput.value = '';
            videoPreviewArea.classList.remove('active');
            videoDropZone.style.display = 'block';
        });

        videoConvertBtn.addEventListener('click', async () => {
            if (!currentVideoFile) return;

            const targetFormat = document.querySelector('input[name="videoFormat"]:checked').value;
            const resolution = document.querySelector('input[name="videoResolution"]:checked').value;
            const filename = videoOutputFilename.value || 'video';

            videoProgressContainer.classList.add('active');
            videoProgressFill.style.width = '10%';
            videoProgressText.textContent = 'Preparing video...';

            try {
                let blob;
                
                if (targetFormat === 'gif') {
                    blob = await convertVideoToGif(currentVideoFile, resolution);
                } else {
                    blob = await convertVideoFormat(currentVideoFile, targetFormat, resolution);
                }

                videoProgressFill.style.width = '100%';
                videoProgressText.textContent = 'Complete!';

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.${targetFormat}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Video converted successfully!');
            } catch (error) {
                console.error('Video conversion error:', error);
                showToast('Error converting video. Try a shorter clip or different format.', true);
            }

            setTimeout(() => {
                videoProgressContainer.classList.remove('active');
            }, 500);
        });

        // Video conversion using Canvas and MediaRecorder
        async function convertVideoFormat(file, format, resolution) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);
                video.muted = true;
                
                video.onloadedmetadata = async () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set resolution
                    let width = video.videoWidth;
                    let height = video.videoHeight;
                    
                    if (resolution !== 'original') {
                        const targetHeight = parseInt(resolution);
                        const scale = targetHeight / height;
                        width = Math.round(width * scale);
                        height = targetHeight;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const mimeType = format === 'webm' ? 'video/webm' : 'video/mp4';
                    const stream = canvas.captureStream(30);
                    
                    // Try to capture audio if available
                    try {
                        const audioCtx = new AudioContext();
                        const source = audioCtx.createMediaElementSource(video);
                        const dest = audioCtx.createMediaStreamDestination();
                        source.connect(dest);
                        source.connect(audioCtx.destination);
                        dest.stream.getAudioTracks().forEach(track => stream.addTrack(track));
                    } catch (e) {
                        console.log('Audio capture not supported');
                    }
                    
                    const recorder = new MediaRecorder(stream, { mimeType });
                    const chunks = [];
                    
                    recorder.ondataavailable = (e) => chunks.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: mimeType });
                        resolve(blob);
                    };
                    
                    recorder.start();
                    video.play();
                    
                    const drawFrame = () => {
                        if (video.paused || video.ended) {
                            recorder.stop();
                            return;
                        }
                        ctx.drawImage(video, 0, 0, width, height);
                        videoProgressFill.style.width = `${(video.currentTime / video.duration) * 90 + 10}%`;
                        requestAnimationFrame(drawFrame);
                    };
                    
                    drawFrame();
                };
                
                video.onerror = reject;
            });
        }

        async function convertVideoToGif(file, resolution) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);
                video.muted = true;
                
                video.onloadedmetadata = async () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    let width = video.videoWidth;
                    let height = video.videoHeight;
                    
                    // Limit GIF size
                    const maxSize = resolution !== 'original' ? parseInt(resolution) : 480;
                    if (height > maxSize) {
                        const scale = maxSize / height;
                        width = Math.round(width * scale);
                        height = maxSize;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const frames = [];
                    const fps = 10;
                    const duration = Math.min(video.duration, 10); // Max 10 seconds for GIF
                    const frameCount = Math.floor(duration * fps);
                    
                    video.currentTime = 0;
                    
                    const captureFrame = (frameIndex) => {
                        return new Promise((resolveFrame) => {
                            video.onseeked = () => {
                                ctx.drawImage(video, 0, 0, width, height);
                                frames.push(canvas.toDataURL('image/png'));
                                videoProgressFill.style.width = `${(frameIndex / frameCount) * 80 + 10}%`;
                                resolveFrame();
                            };
                            video.currentTime = frameIndex / fps;
                        });
                    };
                    
                    for (let i = 0; i < frameCount; i++) {
                        await captureFrame(i);
                    }
                    
                    videoProgressText.textContent = 'Creating GIF...';
                    
                    // Create animated GIF using a simple approach (convert first frame for now)
                    // For full GIF animation, you'd need gif.js library
                    const response = await fetch(frames[0]);
                    const blob = await response.blob();
                    
                    // Note: Full GIF animation would require additional library
                    showToast('Note: Animated GIF creation requires additional processing. Downloaded first frame as image.', false);
                    resolve(blob);
                };
                
                video.onerror = reject;
            });
        }

        // ================================================
        // AUDIO CONVERTER
        // ================================================
        const audioDropZone = document.getElementById('audioDropZone');
        const audioFileInput = document.getElementById('audioFileInput');
        const audioPreviewArea = document.getElementById('audioPreviewArea');
        const audioPreview = document.getElementById('audioPreview');
        const audioFileBadge = document.getElementById('audioFileBadge');
        const audioFileSize = document.getElementById('audioFileSize');
        const audioDurationText = document.getElementById('audioDurationText');
        const audioRemoveBtn = document.getElementById('audioRemoveBtn');
        const audioConvertBtn = document.getElementById('audioConvertBtn');
        const audioOutputFilename = document.getElementById('audioOutputFilename');
        const audioBitrateSlider = document.getElementById('audioBitrateSlider');
        const audioBitrateValue = document.getElementById('audioBitrateValue');
        const audioProgressContainer = document.getElementById('audioProgressContainer');
        const audioProgressFill = document.getElementById('audioProgressFill');
        const audioProgressText = document.getElementById('audioProgressText');

        let currentAudioFile = null;

        // Audio bitrate slider
        audioBitrateSlider.addEventListener('input', (e) => {
            audioBitrateValue.textContent = `${e.target.value} kbps`;
        });

        // Audio drop zone handlers
        audioDropZone.addEventListener('click', () => audioFileInput.click());
        audioDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            audioDropZone.classList.add('dragover');
        });
        audioDropZone.addEventListener('dragleave', () => audioDropZone.classList.remove('dragover'));
        audioDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            audioDropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleAudioFile(e.dataTransfer.files[0]);
            }
        });
        audioFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleAudioFile(e.target.files[0]);
            }
        });

        function handleAudioFile(file) {
            if (!file.type.startsWith('audio/')) {
                showToast('Please select a valid audio file', true);
                return;
            }

            currentAudioFile = file;
            const url = URL.createObjectURL(file);
            audioPreview.src = url;
            
            audioPreview.onloadedmetadata = () => {
                const duration = audioPreview.duration;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                audioDurationText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            };
            
            const ext = file.name.split('.').pop().toUpperCase();
            audioFileBadge.textContent = ext;
            audioFileSize.textContent = formatFileSize(file.size);
            audioOutputFilename.value = file.name.replace(/\.[^/.]+$/, '');
            
            audioDropZone.style.display = 'none';
            audioPreviewArea.classList.add('active');
        }

        audioRemoveBtn.addEventListener('click', () => {
            currentAudioFile = null;
            audioPreview.src = '';
            audioFileInput.value = '';
            audioPreviewArea.classList.remove('active');
            audioDropZone.style.display = 'block';
        });

        audioConvertBtn.addEventListener('click', async () => {
            if (!currentAudioFile) return;

            const targetFormat = document.querySelector('input[name="audioFormat"]:checked').value;
            const filename = audioOutputFilename.value || 'audio';

            audioProgressContainer.classList.add('active');
            audioProgressFill.style.width = '10%';
            audioProgressText.textContent = 'Converting audio...';

            try {
                const blob = await convertAudioFormat(currentAudioFile, targetFormat);
                
                audioProgressFill.style.width = '100%';
                audioProgressText.textContent = 'Complete!';

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.${targetFormat}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Audio converted successfully!');
            } catch (error) {
                console.error('Audio conversion error:', error);
                showToast('Error converting audio', true);
            }

            setTimeout(() => {
                audioProgressContainer.classList.remove('active');
            }, 500);
        });

        async function convertAudioFormat(file, format) {
            return new Promise((resolve, reject) => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        const audioBuffer = await audioContext.decodeAudioData(e.target.result);
                        
                        audioProgressFill.style.width = '50%';
                        
                        // For WAV format, we can encode directly
                        if (format === 'wav') {
                            const wavBlob = audioBufferToWav(audioBuffer);
                            resolve(wavBlob);
                            return;
                        }
                        
                        // For other formats, use MediaRecorder
                        const offlineCtx = new OfflineAudioContext(
                            audioBuffer.numberOfChannels,
                            audioBuffer.length,
                            audioBuffer.sampleRate
                        );
                        
                        const source = offlineCtx.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(offlineCtx.destination);
                        source.start();
                        
                        const renderedBuffer = await offlineCtx.startRendering();
                        
                        // Create audio element and capture
                        const mediaStreamDest = audioContext.createMediaStreamDestination();
                        const newSource = audioContext.createBufferSource();
                        newSource.buffer = renderedBuffer;
                        newSource.connect(mediaStreamDest);
                        newSource.connect(audioContext.destination);
                        
                        const mimeType = format === 'ogg' ? 'audio/ogg' : 'audio/webm';
                        const recorder = new MediaRecorder(mediaStreamDest.stream, { mimeType });
                        const chunks = [];
                        
                        recorder.ondataavailable = (e) => chunks.push(e.data);
                        recorder.onstop = () => {
                            const blob = new Blob(chunks, { type: mimeType });
                            resolve(blob);
                        };
                        
                        recorder.start();
                        newSource.start();
                        
                        setTimeout(() => {
                            recorder.stop();
                        }, (renderedBuffer.duration * 1000) + 100);
                        
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const samples = buffer.length;
            const dataSize = samples * blockAlign;
            const bufferSize = 44 + dataSize;
            
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            // Write audio data
            const channelData = [];
            for (let i = 0; i < numChannels; i++) {
                channelData.push(buffer.getChannelData(i));
            }
            
            let offset = 44;
            for (let i = 0; i < samples; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, channelData[channel][i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // ================================================
        // ARCHIVE CONVERTER
        // ================================================
        const archiveDropZone = document.getElementById('archiveDropZone');
        const archiveFileInput = document.getElementById('archiveFileInput');
        const archivePreviewArea = document.getElementById('archivePreviewArea');
        const archiveContents = document.getElementById('archiveContents');
        const archiveFileBadge = document.getElementById('archiveFileBadge');
        const archiveFileSize = document.getElementById('archiveFileSize');
        const archiveFileCountText = document.getElementById('archiveFileCountText');
        const archiveRemoveBtn = document.getElementById('archiveRemoveBtn');
        const archiveConvertBtn = document.getElementById('archiveConvertBtn');
        const archiveOutputFilename = document.getElementById('archiveOutputFilename');
        const archiveProgressContainer = document.getElementById('archiveProgressContainer');
        const archiveProgressFill = document.getElementById('archiveProgressFill');
        const archiveProgressText = document.getElementById('archiveProgressText');

        let currentArchiveFiles = [];
        let isZipFile = false;
        let currentZipContent = null;

        // Archive drop zone handlers
        archiveDropZone.addEventListener('click', () => archiveFileInput.click());
        archiveDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            archiveDropZone.classList.add('dragover');
        });
        archiveDropZone.addEventListener('dragleave', () => archiveDropZone.classList.remove('dragover'));
        archiveDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            archiveDropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleArchiveFiles(Array.from(e.dataTransfer.files));
            }
        });
        archiveFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleArchiveFiles(Array.from(e.target.files));
            }
        });

        async function handleArchiveFiles(files) {
            // Check if it's a ZIP file
            if (files.length === 1 && files[0].name.toLowerCase().endsWith('.zip')) {
                isZipFile = true;
                currentArchiveFiles = [];
                
                try {
                    const zip = await JSZip.loadAsync(files[0]);
                    currentZipContent = zip;
                    
                    archiveFileBadge.textContent = 'ZIP';
                    archiveFileSize.textContent = formatFileSize(files[0].size);
                    
                    // List contents
                    const fileNames = Object.keys(zip.files);
                    archiveFileCountText.textContent = `${fileNames.length} files`;
                    
                    archiveContents.innerHTML = '';
                    fileNames.forEach(name => {
                        const file = zip.files[name];
                        if (!file.dir) {
                            const item = document.createElement('div');
                            item.className = 'archive-item';
                            item.innerHTML = `
                                <svg viewBox="0 0 24 24"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
                                <span class="archive-item-name">${name}</span>
                            `;
                            archiveContents.appendChild(item);
                        }
                    });
                    
                    // Set extract as default action
                    document.getElementById('archiveActionExtract').checked = true;
                    archiveConvertBtn.textContent = 'Extract Files';
                    archiveOutputFilename.value = files[0].name.replace('.zip', '');
                    
                } catch (error) {
                    showToast('Error reading ZIP file', true);
                    return;
                }
            } else {
                isZipFile = false;
                currentZipContent = null;
                currentArchiveFiles = files;
                
                archiveFileBadge.textContent = 'FILES';
                
                let totalSize = 0;
                files.forEach(f => totalSize += f.size);
                archiveFileSize.textContent = formatFileSize(totalSize);
                archiveFileCountText.textContent = `${files.length} files`;
                
                // List files
                archiveContents.innerHTML = '';
                files.forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'archive-item';
                    item.innerHTML = `
                        <svg viewBox="0 0 24 24"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
                        <span class="archive-item-name">${file.name}</span>
                        <span class="archive-item-size">${formatFileSize(file.size)}</span>
                    `;
                    archiveContents.appendChild(item);
                });
                
                // Set create ZIP as default action
                document.getElementById('archiveActionZip').checked = true;
                archiveConvertBtn.textContent = 'Create ZIP';
                archiveOutputFilename.value = 'archive';
            }
            
            archiveDropZone.style.display = 'none';
            archivePreviewArea.classList.add('active');
        }

        // Update button text based on action selection
        document.querySelectorAll('input[name="archiveAction"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                archiveConvertBtn.textContent = e.target.value === 'zip' ? 'Create ZIP' : 'Extract Files';
            });
        });

        archiveRemoveBtn.addEventListener('click', () => {
            currentArchiveFiles = [];
            currentZipContent = null;
            isZipFile = false;
            archiveFileInput.value = '';
            archiveContents.innerHTML = '';
            archivePreviewArea.classList.remove('active');
            archiveDropZone.style.display = 'block';
        });

        archiveConvertBtn.addEventListener('click', async () => {
            const action = document.querySelector('input[name="archiveAction"]:checked').value;
            const filename = archiveOutputFilename.value || 'archive';

            archiveProgressContainer.classList.add('active');
            archiveProgressFill.style.width = '10%';

            try {
                if (action === 'zip' && currentArchiveFiles.length > 0) {
                    archiveProgressText.textContent = 'Creating ZIP...';
                    
                    const zip = new JSZip();
                    
                    for (let i = 0; i < currentArchiveFiles.length; i++) {
                        const file = currentArchiveFiles[i];
                        const content = await file.arrayBuffer();
                        zip.file(file.name, content);
                        archiveProgressFill.style.width = `${(i / currentArchiveFiles.length) * 80 + 10}%`;
                    }
                    
                    archiveProgressText.textContent = 'Compressing...';
                    const blob = await zip.generateAsync({ type: 'blob' });
                    
                    archiveProgressFill.style.width = '100%';
                    archiveProgressText.textContent = 'Complete!';
                    
                    // Download
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${filename}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('ZIP file created successfully!');
                    
                } else if (action === 'extract' && currentZipContent) {
                    archiveProgressText.textContent = 'Extracting files...';
                    
                    const files = Object.keys(currentZipContent.files);
                    let downloadCount = 0;
                    
                    for (const fileName of files) {
                        const file = currentZipContent.files[fileName];
                        if (!file.dir) {
                            const content = await file.async('blob');
                            
                            const url = URL.createObjectURL(content);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileName.split('/').pop();
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            downloadCount++;
                            archiveProgressFill.style.width = `${(downloadCount / files.length) * 90 + 10}%`;
                            
                            // Delay between downloads
                            await new Promise(r => setTimeout(r, 200));
                        }
                    }
                    
                    archiveProgressFill.style.width = '100%';
                    archiveProgressText.textContent = 'Complete!';
                    showToast(`Extracted ${downloadCount} files!`);
                }
            } catch (error) {
                console.error('Archive error:', error);
                showToast('Error processing archive', true);
            }

            setTimeout(() => {
                archiveProgressContainer.classList.remove('active');
            }, 500);
        });
    </script>
</body>
</html>
